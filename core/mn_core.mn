--
-- Copyright (c) 2021 lalawue
--
-- This library is free software; you can redistribute it and/or modify it
-- under the terms of the MIT license. See LICENSE for details.
--

import parse from "mn_parser" {}
import compile from "mn_compile" {}
import split, posLine from "mn_utils" {}
import concat, insert, remove from table {}

unpack = unpack or table.unpack

-- create mnpath from pkg_path
fn createPath(pkg_path) {
    tbl = {}
    list = split(pkg_path, ";")
    for i = 1, #list {
        prefix = list[i]:match("^(.-)%.lua")
        if prefix {
            tbl[#tbl + 1] = prefix .. ".mn"
        }
    }
    return concat(tbl, ";")
}

-- mn source to AST
fn toAST(config, text) {
    t = type(text)
    if t ~= "string" {
        return nil, "expecting string (got " .. t .. ")"
    }
    config = config or {}
    ret, tbl = parse(text)
    if not ret {
        err = posLine(tbl.content, tbl.lpos, tbl.cpos)
        msg = string.format("parse error %s:%d: %s", config.fname, err.line, err.message)
        return nil, msg
    }
    return tbl
}

-- translate to Lua
fn toLua(config, tbl) {
    ret, code = compile(config, tbl)
    if not ret {
        return nil, code
    }
    return code
}

-- directory separator
dir_spliter = package.config and package.config[1] or '/'
all_option = _VERSION == "Lua 5.1" and "*a" or "a"
tmp_config = {}

-- register ?.mn loader
fn mnLoader(name) {
    name_path = name:gsub("%.", dir_spliter)
    file, file_path = nil, nil
    for path in package.mnpath:gmatch("[^;]+") {
        file_path = path:gsub("?", name_path)
        file = io.open(file_path)
        if file {
            break
        }
    }
    text = nil
    if file {
        text = file:read(all_option)
        file:close()
    } else {
        return nil, "Could not find mn file"
    }
    tmp_config.fname = file_path
    res, emsg = toAST(tmp_config, text)
    if not res {
        error(emsg)
    }
    res, emsg = toLua(tmp_config, res)
    if not res {
        error(emsg)
    }
    f, err = load(res, file_path)
    return f
}

fn mnLoadString(text, cname, mode, env) {
    tmp_config.fname = cname
    res, emsg = toAST(tmp_config, text)
    if not res {
        return emsg
    }
    res, emsg = toLua(tmp_config, res)
    if not res {
        return emsg
    }
    f = (loadstring or load)
    return f(res, cname, unpack({ mode : mode, env : env }))
}

fn mnLoadFile(fname, ...) {
    f, err = io.open(fname)
    if not f {
      return nil, err
    }
    local text = assert(f:read(all_option))
    f:close()
    return mnLoadString(text, fname, ...)
}

fn mnDoFile(...) {
    f = assert(mnLoadFile(...))
    return f()
}

fn mnRemoveLoader() {
    loaders = package.loaders or package.searchers
    for i, loader in ipairs(loaders) {
        if loader == mnLoader {
            remove(loaders, i)
            package.mnpath = nil
            return true
        }
    }
    return false    
}

fn mnVersion() {
    return "mnscript v0.0.3"
}

-- run
if not package.mnpath {
    package.mnpath = createPath(package.path)
    loaders = package.loaders or package.searchers
    has_loader = false
    for i=1, #loaders {
        if loaders[i] == mnLoader {
            has_loader = true
        }
    }
    if not has_loader {
        insert(loaders, mnLoader)
    }
}

return {
    loadstring : mnLoadString,
    loadfile : mnLoadFile,
    dofile : mnDoFile,
    removeloader : mnRemoveLoader,
    toAST : toAST,
    toLua : toLua,
    version : mnVersion
}