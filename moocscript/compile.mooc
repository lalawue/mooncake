--
-- Copyright (c) 2021 lalawue
--
-- This library is free software; you can redistribute it and/or modify it
-- under the terms of the MIT license. See LICENSE for details.
--

import Utils from "moocscript.utils"
local setmetatable = setmetatable
local assert = assert
local type = type
local srep = string.rep
local ipairs = ipairs
local mathmax = math.max

struct Out {

    _indent = 0
    _changeLine = false
    _output = {}
    _inline = 0

    fn init() {
        self._indent = 0 -- indent char
        self._changeLine = false -- force change line
        self._output = {} -- output table
        self._inline = 0 -- force expr oneline
    }

    fn incIndent() {
        self._indent = self._indent + 1
    }

    fn decIndent() {
        self._indent = self._indent - 1
    }

    fn changeLine() {
        self._changeLine = true
    }

    fn pushInline() {
        self._inline = self._inline + 1
    }

    fn popInline() {
        self._inline = self._inline - 1
    }

    fn append(str, same_line) {
        assert(type(str) == "string", "Invalid input")        
        t = self._output
        same_line = same_line or (self._inline > 0)
        if same_line and not self._changeLine {
            i = mathmax(#t, 1)
            t[i] = (t[i] or "") .. str
        } else {
            self._changeLine = false
            prefix = self._indent > 0 and srep("\t", self._indent) or ""
            t[#t + 1] = prefix .. str
        }
    }

    fn getInfo() {
        return { #self._output, self._indent }
    }

    fn appendExt(info, tbl) {
        t = self._output
        if #info > 1 and info[1] <= #t {
            idx, indent = info[1], info[2]
            prefix = indent > 0 and srep("\t", indent) or ""
            for _, v in ipairs(tbl) {
                t[idx] = (t[idx] or "") .. "\n" .. prefix .. v
            }
        }
    }
}

local _global_names = Utils.set({
    "_G",
    "_VERSION",
    "_ENV",
    "assert",
    "collectgarbage",
    "coroutine",
    "debug",
    "dofile",
    "error",
    "getfenv",
    "getmetatable",
    "io",
    "ipairs",
    "jit",
    "load",
    "loadfile",
    "loadstring",
    "math",
    "module",
    "next",
    "os",
    "package",
    "pairs",
    "pcall",
    "print",
    "rawequal",
    "rawget",
    "rawlen",
    "rawset",
    "require",
    "select",
    "setfenv",
    "setmetatable",
    "string",
    "table",
    "tonumber",
    "tostring",
    "type",
    "unpack",
    "xpcall",
    "nil",
    "true",
    "false",
})

local _scope_global = { otype : "gl", vars : _global_names }
local _scope_proj = { otype : "pj", vars : {} }

struct Ctx {

    config = false
    ast = false
    content = false

    scopes = false    
    in_defer = false
    in_clsvar = false
    in_clsname = false
    in_supname = false

    err_info = false
    last_pos = 0

    -- MARK:

    fn init(config, ast, content) {
        self.config = config
        self.ast = ast
        self.content = content
        -- { otype : "gl|pj|fi|cl|fn|lo|if|do|gu", vars : {} }
        self.scopes = {
            _scope_global,
            _scope_proj,
            { otype : "fi", vars : {}, loidx : 0 }
        }
    }

    fn pushScope(ot, exp) {
        t = self.scopes
        scope = { otype : ot, vars : {}, exp : exp }
        t[#t + 1] = scope
        if ot == "lo" {
            t[3].loidx += 1
            scope.loidx =  t[3].loidx
        }
    }

    fn popScope() {
        t = self.scopes
        t[#t] = nil
    }

    fn getScope(otype) {
        t = self.scopes
        for i = #t, 1, -1 {
            v = t[i]
            if v.otype == otype {
                return v
            }
        }
    }

    fn supportDefer() {
        t = self.scopes
        for i = #t, 3, -1 {
            if t[i].otype == "fn" {
                return true
            }
        }
        return false
    }

    fn isInLoop() {
        t = self.scopes
        for i = #t, 3, -1 {
            otype = t[i].otype
            if otype == "fn" {
                return false
            } elseif otype == "lo" {
                return true
            }
        }
        return false
    }

    fn pushDefer() {
        t = self.scopes
        for i = #t, 3, -1 {
            v = t[i]
            if v.otype == "fn" {
                v.has_defer = true
                break
            }
        }
    }

    fn hasDefers(){
        t = self.scopes
        for i = #t, 3, -1 {
            v = t[i]
            if v.otype == "fn" {
                return v.has_defer
            }
        }
        return false
    }

    fn pushOutInfo(info) {
        t = self.scopes
        t[#t].info = info
    }

    fn getOutInfo(otype) {
        t = self.scopes
        for i = #t, 3, -1 {
            v = t[i]
            if v.otype == otype {
                return v.info                
            }
        }
    }

    fn globalInsert(n) {
        t = self.scopes
        t[2].vars[n] = true
    }

    fn localInsert(n) {
        t = self.scopes
        t[#t].vars[n] = true
    }

    -- treat lvar as to be defined, grammar checking
    fn checkName(e, checkLeftLocal, onlyList1st) {
        ret, name, pos = self:isVarDeclared(e, checkLeftLocal, onlyList1st)
        if ret {
            return
        }
        self:errorPos("undefined variable", name, pos - 1)
    }

    -- checkLeftLocal: check left define, in transform to Lua
    fn isVarDeclared(e, checkLeftLocal, onlyList1st) {
        n, pos = nil, nil
        assert(type(e) == "table", "Invalid var declare type")
        etype = e.etype
        if etype == "lvar" and e.list {
            n = e.list[1]
            pos = e.pos
        } elseif etype == "lvar" and checkLeftLocal and not onlyList1st {
            n = e.value
            pos = e.pos
        } elseif etype == "rvar" {
            n = e.list and e.list[1] or e.value
            pos = e.pos
        } elseif etype == "lexp" and checkLeftLocal and not onlyList1st {
            n = e[1].value
            pos = e[1].pos
        } else {
            return true
        }
        t = self.scopes
        for i = #t, 1, -1 {
            if t[i].vars[n] or t[i].vars["*"] {
                return true
            }
        }
        return false, n, pos
    }

    fn errorPos(msg, symbol, pos) {
        if self.err_info {
            return
        }
        pos = pos or mathmax(0, self.last_pos - 1)
        err = Utils.posLine(self.content, pos)
        self.err_info = string.format("%s:%d: %s <%s '%s'>", self.config.fname or "_", err.line, err.message, msg, symbol)
    }

    fn hasError() {
        return self.err_info
    }

    fn updatePos(pos) {
        if type(pos) == "number" and not self.err_info {
            self.last_pos = pos
        }
    }
}

--[[
]]

    -- class and instance metamethod except __tostring, __index, __newindex, __call
local _cls_metafns = Utils.set({"__add",
                                "__band",
                                "__bnot",
                                "__bor",
                                "__bxor",
                                "__close",
                                "__concat",
                                "__div",
                                "__eq",
                                "__idiv",
                                "__le",
                                "__len",
                                "__lt",
                                "__metatable",
                                "__mod",
                                "__mode",
                                "__mul",
                                "__name",
                                "__pairs",
                                "__pow",
                                "__shl",
                                "__shr",
                                "__sub",
                                "__unm"})

local _no_space_op = Utils.set({"(", ")", "#", "~", "-"})
local _right_space_op = Utils.set({"not"})

struct M {

    ctx = false
    out = false
    opfn = {}
    exfn = {}
    stfn = {}

    fn init(ctx, out) {
        self.ctx = ctx
        self.out = out
    }

    fn trOp(t) {
        ctx = self.ctx
        ctx:updatePos(t.pos)
        op = t.op
        func = self.opfn[op]
        if func {
            func(self, t)
            return
        }
        switch op {
        case "(":
            func = self.trOpPara
        case ".":
            func = self.trOpDot
        case ":":
            func = self.trOpColon
        case "[":
            func = self.trOpSquare
        default:
            ctx:errorPos("Invalid op near", (t.op or "unknown"))
            return
        }
        self.opfn[op] = func
        func(self, t)
    }

    fn trExpr(t) {
        assert(type(t) == "table", "Invalid expr type")
        ctx = self.ctx
        out = self.out
        etype = t.etype
        func = self.exfn[etype or t.op]
        ctx:updatePos(t.pos)
        if func {
            func(self, t)
            return
        }
        switch etype {
        case "lvar":
            func = { self, t in
                local ctx = self.ctx
                local out = self.out
                if not ctx.in_clsvar {
                    ctx:checkName(t)
                }
                if ctx.in_clsname and t.value == "Self" {
                    out:append(ctx.in_clsname, true)
                } elseif ctx.in_supname and t.value == "Super" {
                    out:append(ctx.in_supname, true)
                } else {
                    out:append(t.value, true)
                }
            }
        case "rvar":
            func = { self, t in
                local ctx = self.ctx
                local out = self.out            
                ctx:checkName(t)
                if ctx.in_clsname and t.value == "Self" {
                    out:append(ctx.in_clsname, true)
                } elseif ctx.in_supname and t.value == "Super" {
                    out:append(ctx.in_supname, true)
                } else {
                    out:append(t.value, true)
                }
            }
        case "number":
            func = { self, t in
                self.out:append(t.value, true)
            }
        case "string":
            func = { self, t in
                self.out:append(t.value, true)
            }
        case "varg":
            func = { self, t in
                self.out:append("...", true)
            }
        case "op":
            func = { self, t in
                local out = self.out
                if _no_space_op[t.value] and not t.sub {
                    out:append(t.value, true)
                } elseif _right_space_op[t.value] {
                    out:append(t.value .. " ", true)
                } elseif t.value == "!=" {
                    out:append(" ~= ", true)
                } else {
                    out:append(" " .. t.value .. " ", true)
                }
            }
        case "{":
            func = self.trEtTblDef
        case "fn":
            func = self.trEtFnOnly
        case "rexp":
            func = self.trEtRexp
        case "lexp":
            func = self.trEtLexp
        case "sexp":
            func = self.trEtSexp
        default:
            if t.op {
                func = self.trOp
            } else {
                ctx:errorPos("Invalid expr etype near", (etype or "unknown"))
                return
            }
        }
        self.exfn[etype or t.op] = func
        func(self, t)
    }

    fn trStatement(ast) {
        ctx = self.ctx
        out = self.out
        stfn = self.stfn
        index = 0
        while true {
            index += 1
            if index > #ast {
                break
            }
            t = ast[index]
            stype = t.stype
            func = stfn[stype]
            if func {
                func(self, t)
            } else {
                switch stype {
                case "cm":
                    func = self.trStComment
                case "import":
                    func = self.trStImport
                case "fn":
                    func = self.trStFnDef
                case "(":
                    func = self.trStCall
                case "class":
                    func = self.trStClass
                case "struct":
                    func = self.trStStruct
                case "extension":
                    func = self.trStExtension
                case "ex":
                    func = self.trStExport
                case "return":
                    func = self.trStReturn
                case "defer":
                    func = self.trStDefer
                case "if", "elseif", "else", "ifend":
                    func = self.trStIfElse
                case "switch":
                    func = self.trStSwitch
                case "guard":
                    func = self.trStGuard
                case "break":
                    func = self.trStBreak
                case "continue":
                    func = self.trStContinue
                case "goto", "::":
                    func = self.trStGoto
                case "for":
                    func = self.trStFor
                case "while":
                    func = self.trStWhile
                case "repeat":
                    func = self.trStRepeat
                case "=":
                    -- a = b * (2 + 4)
                    func = self.trStEqual
                case "do":
                    func = self.trStDo
                case "raw":
                    -- generate by compiler
                    func = self.trStRaw
                case ";":
                    func = { self, _ in
                        self.out:append(";", true)
                    }
                case "#!":
                    func = { self, _ in
                        if self.ctx.config.shebang {
                            self.out:append("#!/usr/bin/env lua")
                        }
                    }
                default:
                    if stype and stype:sub(stype:len(), stype:len()) == "=" {
                        -- q ..= "hello"
                        func = self.trStTwoEqual
                    } else {
                        ctx:errorPos("Invalid stype near", (stype or "uknown stype"))
                        return
                    }
                }
                stfn[stype] = func
                func(self, t)
            }
            nstype = ast[index + 1] and ast[index + 1].stype
            if stype ~= ";" {
                out:changeLine()
            }
        }
    }

    -- MARK: Op

    fn trOpPara(t) {
        assert(t.op == "(", "Invalid op (")
        out = self.out
        out:pushInline()
        out:append("(", true)
        for i, e in ipairs(t) {
            if i > 1 {
                out:append(", ", true)
            }
            for _, v in ipairs(e) {
                self:trExpr(v)
            }
        }
        out:append(")", true)
        out:popInline()
    }

    fn trOpDot(t) {
        assert(t.op == ".", "Invalid op .")
        out = self.out
        out:append("." .. t[1].value, true)
    }

    fn trOpColon(t) {
        assert(t.op == ":", "Invalid op :")
        out = self.out
        out:append(":", true)
        for i, e in ipairs(t) {
            if e.etype {
                self:trExpr(e)
            } else {
                self:trOp(e)
            }
        }
    }

    fn trOpSquare(t) {
        assert(t.op == "[", "Invalid op [")
        out = self.out
        out:pushInline()
        out:append("[", true)
        for i, e in ipairs(t) {
            self:trExpr(e)
        }
        out:append("]", true)
        out:popInline()
    }

    -- MARK: Expr

    fn trEtTblDef(t) {
        assert(t.etype == "{", "Invalid etype table def")
        ctx = self.ctx
        out = self.out
        out:append("{ ")
        for i, e in ipairs(t) {
            if e.stype {
                self:trStComment(e)
                out:changeLine()
            } else {
                if e.nkey ~= nil {
                    nk = e.nkey
                    out:append(nk.value, true)
                    out:append(" = ", true)
                    out:append(nk.value, true)
                } else {
                    if e.vkey ~= nil {
                        vk = e.vkey
                        out:append(vk.value, true)
                        out:append(" = ", true)
                    } elseif e.bkey ~= nil {
                        bk = e.bkey
                        out:append("[", true)
                        self:trExpr(bk)
                        out:append("] = ", true)
                    }
                    for _, v in ipairs(e.value) {
                        self:trExpr(v)
                    }
                }
                if i < #t {
                    out:append(", ")
                }
            }
        }
        out:append(" }")    
    }

    fn trEtFnOnly(t) {
        assert(t.etype == "fn", "Invalid etype fn def only")
        args = t.args or {}
        body = t.body
        ctx = self.ctx
        out = self.out
        ctx:pushScope("fn", t)
        out:append("function(" .. Utils.seqReduce(args, "", { init, i, v in
            ctx:localInsert(v.value)
            return init .. (i > 1 and ", " or "") .. v.value
        }) .. ")")
        out:incIndent()
        ctx:pushOutInfo(out:getInfo())
        if #body > 0 {
            out:changeLine()
            self:trStatement(body)
            if ctx:hasDefers() and body[#body].stype ~= "return" {
                out:append((#t > 0 and ", " or "") .. "__df_run__()")
                out:changeLine()
            }
        }
        out:decIndent()
        out:append("end")
        ctx:popScope()
    }

    fn trEtRexp(t) {
        assert(t.etype == "rexp", "Invalid etype rexp")
        ctx = self.ctx
        out = self.out
        ctx:checkName(t[1])
        for i, e in ipairs(t) {
            if e.etype {
                self:trExpr(e)
            } elseif e.op {
                self:trOp(e)
            }
        }
    }

    fn trEtLexp(t) {
        assert(t.etype == "lexp", "Invalid etype lexp")
        ctx = self.ctx
        out = self.out
        ctx:checkName(t[1], (#t - 1) > 0)
        for i, e in ipairs(t) {
            if e.etype {
                self:trExpr(e)
            } elseif e.op {
                self:trOp(e)
            }
        }
    }

    fn trEtSexp(t) {
        assert(t.etype == "sexp", "Invalid etype sexp")
        out = self.out
        out:pushInline()
        for i, e in ipairs(t) {
        local prefix = i > 1 and " .. " or ""
            if e.etype == "strraw" {
                if e.value:len() > 0 {
                    out:append(prefix .. '"' .. e.value .. '"')
                }
            } else {
                out:append(prefix .. "tostring(")
                for _, v in ipairs(e) {
                    self:trExpr(v)
                }
                out:append(")")
            }
        }
        out:popInline()
    }

    -- MARK: Statement

    fn trStEqual(t) {
        assert(t.stype == "=", "Invalid stype equal")
        assert(#t == 2, "Invalid asign count")
        ctx = self.ctx
        out = self.out
        out:pushInline()
        for i, v in ipairs(t[1]) {
            if i == 1 {
                if not ctx:isVarDeclared(v, true) {
                    out:append("local ")
                }
            } else {
                out:append(", ")
            }
            self:trExpr(v)
        }
        out:append(" = ")
        for i, v in ipairs(t[2]) {
            if i > 1 {
                out:append(", ")
            }
            for _, n in ipairs(v) {
                self:trExpr(n)
            }
        }
        out:popInline()
        -- name
        for i, e in ipairs(t[1]) {
            if e.etype == "lexp" and #e == 1 {
                ctx:localInsert(e[1].value)
            }
        }
    }

    fn trStTwoEqual(t) {
        tlen = t.stype:len()
        assert(t.stype:sub(tlen, tlen) == "=", "Invalid stype two equal")
        ctx = self.ctx
        out = self.out
        assert(#t == 2, "Invalid asign count")
        out:pushInline()
        ctx:checkName(t[1], true)
        self:trExpr(t[1])
        out:append(" = ")
        self:trExpr(t[1])
        out:append(" " .. t.stype:sub(1, tlen - 1) .. " (")
        for _, v in ipairs(t[2]) {
            self:trExpr(v)
        }
        out:append(")")
        out:popInline()
    }

    fn trStComment(t) {
        assert(t.stype == "cm", "Invalid stype cm")
        self.out:append(t.value)
    }

    fn trStImport(t) {
        assert(t.stype == "import", "Invalid stype import")
        ctx = self.ctx
        out = self.out
        if #t <= 0 {
            out:append("require(" .. t.slib.value .. ")")
        } elseif t[2] == nil {
            lt = t[1][1]        
            if t.slib {
                out:append("local " .. lt.value .. " = require(" .. t.slib.value .. ")")
            } else {
                ctx:checkName(t.tlib, true)
                out:append("local " .. lt.value .. " = " .. t.tlib.value)
            }
            ctx:localInsert(lt.value)
        } elseif t.slib or t.tlib {
            lt = t[1]
            rt = t[2]
            if #rt <= 0 {
                rt = lt
            }
            out:append(Utils.seqReduce(lt, "local ", { init, i, v in
                ctx:localInsert(v.value)
                return init .. (i <= 1 and "" or ", ") .. v.value
            }))
            if t.slib {
                out:append("do")
                out:incIndent()
                out:append("local __lib__ = require(" .. t.slib.value .. ")")
                out:append(Utils.seqReduce(lt, "", { init, i, v in
                    return init .. (i <= 1 and "" or ", ") .. v.value
                }))
                out:append(" = " .. Utils.seqReduce(rt, "", { init, i, v in
                    return init .. (i <= 1 and "__lib__." or ", __lib__.") .. v.value
                }), true)
                out:decIndent()
                out:append("end")
            } else {
                ctx:checkName(t.tlib, true)
                tfirst, tnext = t.tlib.value .. ".", ", " .. t.tlib.value .. "."
                out:append(" = " .. Utils.seqReduce(rt, "", { init, i, v in
                    return init .. (i <= 1 and tfirst or tnext) .. v.value
                }), true)
            }
        } else {
            assert(nil, "Invalid import AST")
        }
    }

    fn trStExport(t) {
        assert(t.stype == "ex", "Invalid stype export")
        ctx = self.ctx
        out = self.out
        out:pushInline()
        if t.attr == "local" {
            out:append("local ")
            for i, v in ipairs(t[1]) {
                if i > 1 {
                    out:append(", ")
                }
                self:trExpr(v)
                ctx:localInsert(v.value)
            }
            if t[2] {
                out:append(" = ")
                for i, e in ipairs(t[2]) {
                    if i > 1 {
                        out:append(", ")
                    }
                    for _, v in ipairs(e) {
                        self:trExpr(v)
                    }
                }
            }
        } elseif t.attr == "export" {
            if t.op == "*" {
                ctx:localInsert("*")
            } else {
                for i, v in ipairs(t[1]) {
                    ctx:globalInsert(v.value)
                }
                if t[2] {
                    for i, v in ipairs(t[1]) {
                        if i > 1 {
                            out:append(",")
                        }
                        self:trExpr(v)
                    }
                    out:append(" = ")
                    for i, e in ipairs(t[2]) {
                        if i > 1 {
                            out:append(", ")
                        }
                        for _, v in ipairs(e) {
                            self:trExpr(v)
                        }
                    }
                }
            }
        } else {
            ctx:errorPos("Invalid export attr near", (t.attr or "unknown"))
        }
        out:popInline()
    }

    fn trStFnDef(t) {
        assert(t.stype == "fn", "Invalid stype fn")
        attr = (t.attr == "export" and "" or "local ")
        name = t.name and t.name.value or ""
        args = t.args or {}
        body = t.body
        ctx = self.ctx
        out = self.out
        ctx:checkName(t.name, true, true)
        if t.attr == "export" {
            ctx:globalInsert(name)
        } else {
            ctx:localInsert(name)
        }
        if name:find(".", 1, true) {
            attr = ""
        }
        ctx:pushScope("fn", t)
        if name:find(":", 1, true) {
            ctx:localInsert("self")
            attr = ""
        }
        out:append(attr .. "function " .. name .. "(" .. Utils.seqReduce(args, "", { init, i, v in
            ctx:localInsert(v.value)
            return init .. (i > 1 and ", " or "") .. v.value
        }) .. ")")
        out:incIndent()
        ctx:pushOutInfo(out:getInfo())
        if #body > 0 {
            out:changeLine()
            self:trStatement(body)
            if ctx:hasDefers() and body[#body].stype ~= "return" {
                out:append((#t > 0 and ", " or "") .. "__df_run__()")
            }
        }
        out:decIndent()
        out:append("end")
        ctx:popScope()
    }

    fn trStCall(t) {
        assert(t.stype == "(", "Invalid stype fn call")
        ctx = self.ctx
        out = self.out
        n = 0
        out:pushInline()        
        if t[1].etype == "lvar" {
            n = 1
            ctx:checkName(t[1], true)
            if ctx.in_clsname and t[1].value == "Self" {
                out:append(ctx.in_clsname, true)
            } elseif ctx.in_supname and t[1].value == "Super" {
                out:append(ctx.in_supname, true)
            } else {
                out:append(t[1].value, true)
            }
        }
        for i, e in ipairs(t) {
            if i > n {
                if e.etype {
                    self:trExpr(e)
                } elseif e.op {
                    self:trOp(e)
                }
            }
        }
        out:popInline()
    }

    fn trStIfElse(t) {
        ctx = self.ctx
        out = self.out
        if t.stype == "if" or t.stype == "elseif" {
            out:append(t.stype .. " ")
            out:pushInline()
            for _, v in ipairs(t.cond) {
                self:trExpr(v)
            }
            out:popInline()
            out:append(" then", true)
            ctx:pushScope("if", t)
            out:changeLine()
            out:incIndent()
            self:trStatement(t.body)
            ctx:popScope()
            out:decIndent()
        } elseif t.stype == "else" {
            ctx:pushScope("if", t)
            out:append("else")        
            out:changeLine()
            out:incIndent()
            self:trStatement(t.body)
            out:decIndent()
            ctx:popScope()
        } elseif t.stype == "ifend" {
            out:append("end")
        } else {
            ctx:errorPos("Invalid stype near", (t.stype or "unknown"))
        }
    }

    fn trStSwitch(t) {
        assert(t.stype == "switch", "Invalid stype switch")
        ctx = self.ctx
        out = self.out
        out:append("local __sw__ = ")
        out:pushInline()
        for _, v in ipairs(t.cond) {
            self:trExpr(v)
        }
        out:popInline()
        out:changeLine()
        for i = 1, #t {
            c = t[i]
            out:pushInline()
            if c.stype == "case" {
                if i == 1 {
                    out:append("if ")
                } else {
                    out:append("elseif ")
                }
                out:append("__sw__ == (")
                for j, s in ipairs(c) {
                    if j > 1 {
                        out:append(") or __sw__ == (")
                    }
                    for _, e in ipairs(s) {
                        self:trExpr(e)
                    }
                }
                out:append(") then")
            } else {
                out:append("else")
            }
            out:changeLine()
            ctx:pushScope("if")
            out:popInline()
            out:incIndent()
            self:trStatement(c.body)
            out:decIndent()
            ctx:popScope()
        }
        out:append("end")
        out:changeLine()
    }

    fn trStGuard(t) {
        assert(t.stype == "guard", "Invalid stype guard")
        ctx = self.ctx
        out = self.out
        body = t.body
        bt = body[#body]
        if #body <= 0 or not (bt.stype == "return" or bt.stype == "goto" or bt.stype == "break" or bt.stype == "continue") {
            ctx:errorPos("guard statement need return/goto/break/continue at last", "guard", t.pos - 1)
            return
        }
        out:append("if not (")
        out:pushInline()
        for _, v in ipairs(t.cond) {
            self:trExpr(v)
        }
        out:append(") then", true)
        out:popInline()
        out:changeLine()
        out:incIndent()
        ctx:pushScope("gu", t)
        self:trStatement(body)
        ctx:popScope()
        out:decIndent()
        out:append("end")
    }

    fn trStFor(t) {
        assert(t.stype == "for", "Invalid stype for")
        list = t.list
        staments = t.body
        ctx = self.ctx
        out = self.out    
        ctx:pushScope("lo", t)
        out:pushInline()
        out:append("for ")
        if list.sub == "=" {
            for i, e in ipairs(list) {
                if i == 1 {
                    self:trExpr(e)
                    out:append(" = ")
                    ctx:localInsert(e.value)
                } else {
                    if i > 2 {
                        out:append(", ")
                    }
                    for _, v in ipairs(e) {
                        self:trExpr(v)
                    }
                }
            }
        } elseif list.sub == "in" {
            for i, e in ipairs(list) {
                if i == #list {
                    out:append(" in ")
                } elseif i > 1 {
                    out:append(", ")
                }
                if i == #list {
                    for j, v in ipairs(e) {
                        if j > 1 {
                            out:append(", ")
                        }
                        for _, z in ipairs(v) {
                            self:trExpr(z)
                        }
                    }
                } else {
                    self:trExpr(e)
                }
                if i ~= #list {
                    ctx:localInsert(e.value)
                }
            }
        } else {
            ctx:errorPos("Invalid sub near", (list.sub or "unknown"))
            return
        }
        out:append(" do")
        out:popInline()
        out:changeLine()
        out:incIndent()
        self:trStatement(staments)
        out:decIndent()
        out:append("end")
        ctx:popScope()
    }

    fn trStWhile(t) {
        assert(t.stype == "while", "Invalid stype while")
        ctx = self.ctx
        out = self.out
        ctx:pushScope("lo", t)
        out:append("while ")    
        out:pushInline()
        for _, v in ipairs(t.cond) {
            self:trExpr(v)
        }
        out:append(" do")
        out:popInline()        
        out:changeLine()
        out:incIndent()
        self:trStatement(t.body)
        out:decIndent()
        out:append("end")
        ctx:popScope()
    }

    fn trStRepeat(t) {
        assert(t.stype == "repeat", "Invalid repeat op")
        ctx = self.ctx
        out = self.out
        ctx:pushScope("lo", t)
        out:append("repeat")
        out:changeLine()
        out:incIndent()
        self:trStatement(t.body)
        out:decIndent()
        out:append("until ")
        out:pushInline()
        for _, v in ipairs(t.cond) {
            self:trExpr(v)
        }
        out:popInline()
        ctx:popScope()
    }

    fn trStBreak(t) {
        assert(t.stype == "break", "Invalid stype break")
        ctx = self.ctx
        out = self.out
        if not ctx:isInLoop() {
            ctx:errorPos("not in loop", t.stype, t.pos - 1)
            return
        }
        out:append("break")
    }

    fn trStContinue(t) {
        assert(t.stype == "continue", "Invalid continue op")
        ctx = self.ctx
        out = self.out
        if not ctx:isInLoop() {
            ctx:errorPos("not in loop", t.stype, t.pos - 1)
            return
        }
        scope = ctx:getScope("lo")
        if scope and scope.exp and scope.exp.body {
            label = "__continue" .. tostring(scope.loidx) .. "__"
            out:append("goto " .. label)
            le = scope.exp.body
            v = le[#le]
            if v.stype == "return" or v.stype == "break" {
                ctx:errorPos("try do { " .. v.stype .. " } for continue will insert label after", v.stype, v.pos - 1)
            } elseif #le == 0 or le[#le].stype ~= "raw" or le[#le].sub ~= "continue" {
                le[#le + 1] = { stype : "raw", sub : "continue", "::" .. label .. "::" }
            }
        }
    }

    fn trStGoto(t) {
        assert(t.stype == "goto" or t.stype == "::", "Invalid stype go")
        out = self.out
        if t.stype == "goto" {
            out:append("goto " .. t.name.value)
        } else {
            out:append("::" .. t.name.value .. "::")
        }
    }

    fn trStReturn(t) {
        assert(t.stype == "return", "Invalid stpye return")
        ctx = self.ctx
        out = self.out
        out:append("return ")
        out:pushInline()
        for i, e in ipairs(t) {
            if i > 1 {
                out:append(", ")
            }
            for _, v in ipairs(e) {
                self:trExpr(v)
            }
        }
        if ctx:hasDefers() {
            out:append((#t > 0 and ", " or "") .. "__df_run__()")
        }
        out:popInline()
    }

    fn trStDefer(t) {
        assert(t.stype == "defer", "Invalid stype defer")
        ctx = self.ctx
        out = self.out
        if not ctx:supportDefer() {
            ctx:errorPos("not in function", t.stype, t.pos)
            return
        }
        if not ctx:hasDefers() {
            ctx:pushDefer()
            info = ctx:getOutInfo("fn")
            if info {
                out:appendExt(info, {
                    "local __df_fns__ = {}",
                    "local __df_run__ = function() local t=__df_fns__; for i=#t, 1, -1 do t[i]() end; end"
                })
            }
        }
        if not ctx.in_defer {
            ctx.in_defer = true
            out:append("__df_fns__[#__df_fns__ + 1] = function()")
            out:changeLine()
            out:incIndent()
            ctx:pushScope("df")
            self:trStatement(t.body)
            ctx:popScope()
            out:decIndent()
            out:append("end")
            ctx.in_defer = false
        }
    }

    fn trStDo(t) {
        assert(t.stype == "do", "Invalid stype do end")
        ctx = self.ctx
        out = self.out
        ctx:pushScope("do")
        out:append("do")
        out:changeLine()
        out:incIndent()
        self:trStatement(t.body)
        out:decIndent()
        out:append("end")
        ctx:popScope()
    }

    -- generated by compiler 1st pass
    fn trStRaw(t) {
        assert(t.stype == "raw", "Invalid stype raw")
        out = self.out
        for _, v in ipairs(t) {
            out:append(v)
            out:changeLine()
        }
    }

    fn trStClass(t) {
        assert(t.stype == "class", "Invalid stype class")
        ctx = self.ctx
        out = self.out
        attr = (t.attr == "export") and "" or "local "
        clsname = t.name.value
        supertype = t.super and t.super.value
        ctx.in_clsname = clsname
        ctx.in_supname = supertype or false
        if t.attr == "export" {
            ctx:globalInsert(clsname)
        } else {
            ctx:localInsert(clsname)
        }
        if supertype {
            ctx:checkName(t.super, true)
        }
        out:append(attr .. clsname .. " = {}")
        out:append("do")
        out:changeLine()
        out:incIndent()
        out:append("local __stype__ = " .. (supertype or "nil"))
        out:append('local __clsname__ = "' .. clsname .. '"')
        out:append("local __clstype__ = " .. clsname)
        if supertype {
            out:append('assert(type(__stype__) == "table" and type(__stype__.classtype) == "table")')
            out:append('for k, v in pairs(__stype__) do __clstype__[k] = v end')
        }
        out:append("__clstype__.typename = __clsname__")
        out:append("__clstype__.typekind = 'class'")
        out:append("__clstype__.classtype = __clstype__")
        out:append("__clstype__.supertype = __stype__")
        if not supertype {
            out:append("__clstype__.isKindOf = function(cls, a) return a and ((cls.classtype == a) or (cls.supertype and cls.supertype:isKindOf(a))) or false end")
        }
        --
        ctx:pushScope("cl")
        ctx:localInsert("Self")
        if ctx.in_supname {
            ctx:localInsert("Super")
        }
        cls_fns, ins_fns = {}, {}
        fn_init, fn_deinit = self:hlVarAndFns(t, "__clstype__", ctx, out, cls_fns, ins_fns) 
        --
        out:append("local __ins_mt__ = {")
        out:incIndent()
        out:append('__tostring = function() return "instance of " .. __clsname__ end,')
        out:append("__index = function(t, k)")
        out:incIndent()
        out:append("local v = __clstype__[k]")
        out:append("if v ~= nil then rawset(t, k, v) end")
        out:append("return v")
        out:decIndent()
        out:append("end,")
        if fn_deinit {
            out:append("__gc = function(t) t:deinit() end,")
        }
        for _, e in ipairs(ins_fns) {
            out:append(e.name.value .. " = function(")
            self:hlFnArgsBody(e, false, true)
        }
        out:decIndent()
        out:append("}")
        --
        out:append("setmetatable(__clstype__, {")
        out:incIndent()
        out:append('__tostring = function() return "class " .. __clsname__ end,')
        out:append('__index = function(_, k)')
        out:incIndent()
        out:append('local v = __stype__ and __stype__[k]')
        out:append('if v ~= nil then rawset(__clstype__, k, v) end')
        out:append('return v')
        out:decIndent()
        out:append('end,')
        out:append("__call = function(_, ...)")
        out:incIndent()
        out:append("local ins = setmetatable({}, __ins_mt__)")
        if fn_deinit {
            out:append('if _VERSION == "Lua 5.1" then')
            out:incIndent()
            out:append("rawset(ins, '__gc_proxy', newproxy(true))")
            out:append("getmetatable(ins.__gc_proxy).__gc = function() ins:deinit() end")
            out:decIndent()
            out:append("end")
        }
        if fn_init {
            out:append("if ins:init(...) == false then return nil end")
        }
        out:append("return ins")
        out:decIndent()
        out:append("end,")
        for _, e in ipairs(cls_fns) {
            out:append(e.name.value .. " = function(")
            self:hlFnArgsBody(e, false, true)
        }
        out:decIndent()
        out:append("})")
        --
        out:decIndent()
        out:append("end")
        ctx:popScope()
        ctx.in_clsname = false
        ctx.in_supname = false
    }
    
    fn trStStruct(t) {
        assert(t.stype == "struct", "Invalid stype struct")
        ctx = self.ctx
        out = self.out
        attr = (t.attr == "export") and "" or "local "
        strname = t.name.value
        ctx.in_clsname = strname
        if t.attr == "export" {
            ctx:globalInsert(strname)
        } else {
            ctx:localInsert(strname)
        }
        out:append(attr .. strname .. " = {}")
        out:append("do")
        out:changeLine()
        out:incIndent()
        out:append('local __clsname__ = "' .. strname .. '"')
        out:append("local __clstype__ = " .. strname)
        out:append("__clstype__.typename = __clsname__")
        out:append("__clstype__.typekind = 'struct'")
        out:append("__clstype__.classtype = __clstype__")
        --
        ctx:pushScope("cl")
        ctx:localInsert("Self")
        cls_fns, ins_fns = {}, {}
        fn_init, fn_deinit = self:hlVarAndFns(t, "__clstype__", ctx, out, cls_fns, ins_fns)
        --
        out:append("local __ins_mt__ = {")
        out:incIndent()
        out:append('__tostring = function() return "one of " .. __clsname__ end,')
        out:append("__index = function(t, k)")
        out:incIndent()
        out:append("local v = rawget(__clstype__, k)")
        out:append("if v ~= nil then rawset(t, k, v) end")
        out:append("return v")
        out:decIndent()
        out:append("end,")
        out:append("__newindex = function(t, k, v) if rawget(__clstype__, k) ~= nil then rawset(t, k, v) end end,")
        if fn_deinit {
            out:append("__gc = function(t) t:deinit() end,")
        }
        for _, e in ipairs(ins_fns) {
            out:append(e.name.value .. " = function(")
            self:hlFnArgsBody(e, false, true)
        }
        out:decIndent()
        out:append("}")
        --
        out:append(strname .. " = setmetatable({}, {")
        out:incIndent()
        out:append('__tostring = function() return "struct " .. __clsname__ end,')
        out:append('__index = function(_, k) return rawget(__clstype__, k) end,')
        out:append('__newindex = function(_, k, v) if v ~= nil and rawget(__clstype__, k) ~= nil then rawset(__clstype__, k, v) end end,')
        out:append("__call = function(_, ...)")
        out:incIndent()
        out:append("local ins = setmetatable({}, __ins_mt__)")
        if fn_init {
            out:append("if ins:init(...) == false then return nil end")
        }
        if fn_deinit {
            out:append('if _VERSION == "Lua 5.1" then')
            out:incIndent()
            out:append("rawset(ins, '__gc_proxy', newproxy(true))")
            out:append("getmetatable(ins.__gc_proxy).__gc = function() ins:deinit() end")
            out:decIndent()
            out:append("end")
        }
        out:append("return ins")
        out:decIndent()
        out:append("end,")
        for _, e in ipairs(cls_fns) {
            out:append(e.name.value .. " = function(")
            self:hlFnArgsBody(e, false, true)
        }
        out:decIndent()
        out:append("})")
        --
        out:decIndent()
        out:append("end")
        ctx:popScope()
        ctx.in_clsname = false
    }

    fn trStExtension(t) {
        assert(t.stype == "extension", "Invalid stype extension")
        ctx = self.ctx
        out = self.out
        clsname = t.name.value
        extype = t.extend and t.extend.value
        ctx.in_clsname = clsname
        ctx:checkName(t.name, true)
        if extype {
            ctx:checkName(t.extend, true)
        }
        out:append("do")
        out:changeLine()
        out:incIndent()
        out:append("local __extype__ = " .. (extype or "nil"))
        out:append("local __clstype__ = " .. clsname)
        out:append('assert(type(__clstype__) == "table" and type(__clstype__.classtype) == "table")')
        out:append("__clstype__ = __clstype__.classtype")
        if extype {
            -- extype can be class or struct
            out:append('assert(type(__extype__) == "table" and type(__extype__.classtype) == "table")')
            out:append('for k, v in pairs(__extype__.classtype) do')
            out:incIndent()
            out:append('if __clstype__[k] == nil and k:sub(1, 2) ~= "__" and k ~= "supertype" and k ~= "isKindOf" then')
            out:incIndent()
            out:append('__clstype__[k] = v')
            out:decIndent()
            out:append("end")
            out:decIndent()
            out:append("end")
        }
        --
        ctx:pushScope("cl")
        ctx:localInsert("Self")
        self:hlVarAndFns(t, "__clstype__", ctx, out, {}, {})    
        out:decIndent()
        out:append("end")
        ctx:popScope()
        ctx.in_clsname = false
    }    

    fn hlVarAndFns(t, sname, ctx, out, cls_fns, ins_fns) {
        out:append("-- declare struct var and methods")
        out:changeLine()
        fn_init = false
        fn_deinit = false
        for _, e in ipairs(t) {
            stype = e.stype
            if stype == "=" {
                ctx.in_clsvar = true         
                out:append(sname .. ".")
                out:pushInline()
                for i, v in ipairs(e) {
                    self:trExpr(v)
                    if i == 1 {
                        out:append(" = ")
                    }
                }
                out:popInline()
                out:changeLine()
                ctx.in_clsvar = false
            } elseif stype == "fn" {
                fn_name = e.name.value
                if fn_name == "init" {
                    fn_init = true
                } elseif fn_name == "deinit" {
                    fn_deinit = true
                }
                fn_ins = e.attr ~= "static"            
                if _cls_metafns[fn_name] {
                    if fn_ins {
                        ins_fns[#ins_fns + 1] = e
                    } else {
                        cls_fns[#cls_fns + 1] = e
                    }
                } else {
                    out:append("function " .. sname .. (fn_ins and ":" or ".") .. fn_name .. "(")
                    self:hlFnArgsBody(e, fn_ins)
                }
            } elseif stype == "cm" {
                self:trStComment(e)
            }
        }
        out:append("-- declare end")
        return fn_init, fn_deinit
    }

    fn hlFnArgsBody(e, fn_ins, comma_end) {
        ctx = self.ctx
        out = self.out
        out:pushInline()
        ctx:pushScope("fn", e)
        if e.args {
            for i, v in ipairs(e.args) {
                if i > 1 {
                    out:append(", ")
                }
                self:trExpr(v)
                ctx:localInsert(v.value)
            }
        }
        if fn_ins {
            ctx:localInsert("self")
        }
        out:append(")")
        out:incIndent()
        out:popInline()
        out:changeLine()
        ctx:pushOutInfo(out:getInfo())
        self:trStatement(e.body)
        out:decIndent()
        out:append("end" .. (comma_end and "," or ""))
        out:changeLine()
        ctx:popScope()
    }
}

--[[
    config as { fname : "filename", shebang : false }    
    data as { content : CONTENT, ast : AST_TREE }
]]
fn compile(config, data) {
    guard type(data) == "table" and data.ast and data.content else {
        return false, "Invalid data"
    }

    ctx = Ctx(config, data.ast, data.content)
    out = Out()
    comp = M(ctx, out)

    comp:trStatement(ctx.ast)

    if ctx:hasError() {
        return false, ctx.err_info
    }

    return true, table.concat(out._output, "\n")
}

-- clear proj exports
fn clearproj() {
    _scope_proj.vars = {}
}

return { :compile, :clearproj }
