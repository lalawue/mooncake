--
-- Copyright (c) 2021 lalawue
--
-- This library is free software; you can redistribute it and/or modify it
-- under the terms of the MIT license. See LICENSE for details.
--

import Utils from "mnscript.utils"

class Out {

    fn init() {
        self:reset()
    }

    fn reset(dryrun) {
        self._indent = 0 -- indent char
        self._changeLine = false -- force change line
        self._output = {} -- output table
        self._inline = 0 -- force expr oneline
        self._dryrun = dryrun
    }

    fn incIndent() {
        self._indent = self._indent + 1
    }

    fn decIndent() {
        self._indent = self._indent - 1
    }

    fn changeLine() {
        self._changeLine = true
    }

    fn pushInline() {
        self._inline = self._inline + 1
    }

    fn popInline() {
        self._inline = self._inline - 1
    }

    fn isDryRun(set) {
        return self._dryrun
    }

    fn append(str, same_line) {
        if self._dryrun {
            return
        }
        assert(type(str) == "string", "Invalid input")        
        t = self._output
        same_line = same_line or (self._inline > 0)
        if same_line and not self._changeLine {
            i = math.max(#t, 1)
            t[i] = (t[i] or "") .. str
        } else {
            self._changeLine = false
            indent = self._indent > 0 and string.rep("\t", self._indent) or ""
            t[#t + 1] = indent .. str
        }
    }
}

local _preserv_keyword = Utils.set({
    "_G",
    "_VERSION",
    "_ENV",
    "assert",
    "bit32",
    "collectgarbage",
    "coroutine",
    "debug",
    "dofile",
    "error",
    "getfenv",
    "getmetatable",
    "io",
    "ipairs",
    "jit",
    "load",
    "loadfile",
    "loadstring",
    "math",
    "module",
    "next",
    "os",
    "package",
    "pairs",
    "pcall",
    "print",
    "rawequal",
    "rawget",
    "rawlen",
    "rawset",
    "require",
    "select",
    "setfenv",
    "setmetatable",
    "string",
    "table",
    "tonumber",
    "tostring",
    "type",
    "unpack",
    "xpcall",
    "nil",
    "true",
    "false",
})

local _scope_global = { otype : "gl", defers : {}, vars : _preserv_keyword }

class Ctx {

    fn init(config, ast, content) {
        self.config = config
        self.ast = ast
        self.content = content
        self:reset()
    }

    fn reset() {
        -- { otype : "gl|fi|fn|lo|if|do|gu", defers : {}, vars : {} }
        self.scopes = {
            _scope_global,
            { otype : "fi", defers : {}, vars : {} }
        }
        self.in_defer = false
        self.in_clsvar = false
        self.error = nil
        self.last_pos = 0
    }

    fn pushScope(ot, exp) {
        t = self.scopes
        t[#t + 1] = { otype : ot, defers : {}, vars : {}, exp : exp}
    }

    fn popScope() {
        t = self.scopes
        t[#t] = nil
    }

    fn supportDefer() {
        t = self.scopes
        if #t > 2 {
            for i = #t, 1, -1 {
                if t[i].otype == "fn" {
                    return true
                }
            }
        }
        return false
    }

    fn isInLoop() {
        t = self.scopes
        if #t > 2 {
            for i = #t, 1, -1 {
                if t[i].otype == "fn" {
                    return false
                } elseif t[i].otype == "lo" {
                    return true
                }
            }
        }
        return false
    }

    fn getScopeExpr(otype) {
        t = self.scopes
        if #t > 2 {
            for i = #t, 1, -1 {
                if t[i].otype == otype {
                    return t[i].exp
                }
            }
        } else {
            return {}
        }
    }

    fn pushDefer() {
        t = self.scopes
        for i = #t, 1, -1 {
            if t[i].otype == "fn" {
                d = t[i].defers
                d[#d + 1] = true
                break
            }
        }
    }

    fn hasDefers(){
        t = self.scopes
        if #t > 2 {
            for i = #t, 1, -1 {
                if #t[i].defers > 0 {
                    return true
                }
                if t[i].otype == "fn" {
                    return false
                }
            }
        }
        return false
    }

    fn globalInsert(n) {
        t = self.scopes
        t[1].vars[n] = true
    }

    fn localInsert(n) {
        t = self.scopes
        t[#t].vars[n] = true
    }

    -- treat lvar as to be defined, grammar checking
    fn checkName(e, checkLeftLocal, onlyList1st) {
        ret, name, pos = self:isVarDeclared(e, checkLeftLocal, onlyList1st)
        if ret {
            return
        }
        self:errorPos("undefined variable", name, pos - 1)
    }

    -- checkLeftLocal: check left define, in transform to Lua
    fn isVarDeclared(e, checkLeftLocal, onlyList1st) {
        n, pos = nil, nil
        assert(type(e) == "table", "Invalid var declare type")
        etype = e.etype
        if etype == "lvar" and e.list {
            n = e.list[1]
            pos = e.pos
        } elseif etype == "lvar" and checkLeftLocal and not onlyList1st {
            n = e.value
            pos = e.pos
        } elseif etype == "rvar" {
            n = e.list and e.list[1] or e.value
            pos = e.pos
        } elseif etype == "lexp" and checkLeftLocal and not onlyList1st {
            n = e[1].value
            pos = e[1].pos
        } else {
            return true
        }
        t = self.scopes
        for i = #t, 1, -1 {
            if t[i].vars[n] {
                return true
            }
        }
        return false, n, pos
    }

    fn errorPos(msg, symbol, pos) {
        if self.error {
            return
        }
        pos = pos or math.max(0, self.last_pos - 1)
        err = Utils.posLine(self.content, pos)
        self.error = string.format("%s:%d: %s <%s '%s'>", self.config.fname or "_", err.line, err.message, msg, symbol)
    }

    fn hasError() {
        return self.error ~= nil
    }

    fn updatePos(pos) {
        if type(pos) == "number" and self.error == nil {
            self.last_pos = pos
        }
    }
}

--[[
]]

    -- class and instance metamethod except __tostring, __index, __newindex, __call
local _cls_metafns = Utils.set({"__add",
                                "__band",
                                "__bnot",
                                "__bor",
                                "__bxor",
                                "__close",
                                "__concat",
                                "__div",
                                "__eq",
                                "__gc",
                                "__idiv",
                                "__le",
                                "__len",
                                "__lt",
                                "__metatable",
                                "__mod",
                                "__mode",
                                "__mul",
                                "__name",
                                "__pairs",
                                "__pow",
                                "__shl",
                                "__shr",
                                "__sub",
                                "__unm"})

local _no_space_op = Utils.set({"(", ")", "#", "~", "-"})
local _right_space_op = Utils.set({"not"})

class M {

    fn init(ctx, out) {
        self.ctx = ctx
        self.out = out
    }

    fn trOp(t) {
        ctx = self.ctx
        ctx:updatePos(t.pos)
        switch t.op {
        case "(":
            self:trOpPara(t)
        case ".":
            self:trOpDot(t)
        case ":":
            self:trOpColon(t)
        case "[":
            self:trOpSquare(t)
        default:
            ctx:errorPos("Invalid op near", (t.op or "unknown"))
        }
    }

    fn trExpr(t) {
        assert(type(t) == "table", "Invalid expr type")
        ctx = self.ctx
        out = self.out
        etype = t.etype
        ctx:updatePos(t.pos)
        switch etype {
        case "lvar":
            if not ctx.in_clsvar {
                ctx:checkName(t)
            }
            out:append(t.value, true)
        case "rvar":
            ctx:checkName(t)
            out:append(t.value, true)
        case "number":
            out:append(t.value, true)
        case "string":
            out:append(t.value, true)
        case "varg":
            out:append("...", true)
        case "op":
            if _no_space_op[t.value] and not t.sub {
                out:append(t.value, true)
            } elseif _right_space_op[t.value] {
                out:append(t.value .. " ", true)
            } elseif t.value == "!=" {
                out:append(" ~= ", true)
            } else {
                out:append(" " .. t.value .. " ", true)
            }
        case "{":
            self:trEtTblDef(t)
        case "fn":
            self:trEtFnOnly(t)
        case "rexp":
            self:trEtRexp(t)
        case "lexp":
            self:trEtLexp(t)
        default:
            if t.op {
                self:trOp(t)
            } else {
                ctx:errorPos("Invalid expr etype near", (etype or "unknown"))
            }
        }
    }

    fn trStatement(ast) {
        ctx = self.ctx
        out = self.out
        index = 0
        while true {
            index += 1
            if index > #ast {
                break
            }
            t = ast[index]
            stype = t.stype
            switch stype {
            case "cm":
                self:trStComment(t)
            case "import":
                self:trStImport(t)
            case "fn":
                self:trStFnDef(t)
            case "(":
                self:trStCall(t)
            case "class":
                self:trStClass(t)
            case "ex":
                self:trStExport(t)
            case "return":
                self:trStReturn(t)
            case "defer":
                self:trStDefer(t)
            case "if", "elseif", "else", "ifend":
                self:trStIfElse(t)
            case "switch":
                self:trStSwitch(t)
            case "guard":
                self:trStGuard(t)
            case "break":
                self:trStBreak(t)
            case "continue":
                self:trStContinue(t)
            case "goto", "::":
                self:trStGoto(t)
            case "for":
                self:trStFor(t)
            case "while":
                self:trStWhile(t)
            case "repeat":
                self:trStRepeat(t)
            case "=":
                -- a = b * (2 + 4)
                self:trStEqual(t)
            case "do":
                self:trStDo(t)
            case "raw":
                -- generate by compiler
                self:trStRaw(t)
            case ";":
                out:append(";", true)
            case "#!":
                if ctx.config.shebang {
                    out:append("#!/usr/bin/env lua")
                }
            default:
                if stype and stype:sub(stype:len(), stype:len()) == "=" {
                    -- q ..= "hello"
                    self:trStTwoEqual(t)
                } else {
                    ctx:errorPos("Invalid stype near", (stype or "uknown stype"))
                    return
                }
            }
            nstype = ast[index + 1] and ast[index + 1].stype
            if stype ~= ";" {
                out:changeLine()
            }
        }
    }

    -- MARK: Op

    fn trOpPara(t) {
        assert(t.op == "(", "Invalid op (")
        out = self.out
        out:pushInline()
        out:append("(", true)
        for i, e in ipairs(t) {
            if i > 1 {
                out:append(", ", true)
            }
            for _, v in ipairs(e) {
                self:trExpr(v)
            }
        }
        out:append(")", true)
        out:popInline()
    }

    fn trOpDot(t) {
        assert(t.op == ".", "Invalid op .")
        out = self.out
        out:append("." .. t[1].value, true)
    }

    fn trOpColon(t) {
        assert(t.op == ":", "Invalid op :")
        out = self.out
        out:append(":", true)
        for i, e in ipairs(t) {
            if e.etype {
                self:trExpr(e)
            } else {
                self:trOp(e)
            }
        }
    }

    fn trOpSquare(t) {
        assert(t.op == "[", "Invalid op [")
        out = self.out
        out:pushInline()
        out:append("[", true)
        for i, e in ipairs(t) {
            self:trExpr(e)
        }
        out:append("]", true)
        out:popInline()
    }

    -- MARK: Expr

    fn trEtTblDef(t) {
        assert(t.etype == "{", "Invalid etype table def")
        ctx = self.ctx
        out = self.out
        out:append("{ ")
        for i, e in ipairs(t) {
            if e.stype {
                self:trStComment(e)
                out:changeLine()
            } else {
                if e.nkey ~= nil {
                    nk = e.nkey
                    out:append(nk.value, true)
                    out:append(" = ", true)
                    out:append(nk.value, true)
                } else {
                    if e.vkey ~= nil {
                        vk = e.vkey
                        out:append(vk.value, true)
                        out:append(" = ", true)
                    } elseif e.bkey ~= nil {
                        bk = e.bkey
                        out:append("[", true)
                        self:trExpr(bk)
                        out:append("] = ", true)
                    }
                    for _, v in ipairs(e.value) {
                        self:trExpr(v)
                    }
                }
                if i < #t {
                    out:append(", ")
                }
            }
        }
        out:append(" }")    
    }

    fn trEtFnOnly(t) {
        assert(t.etype == "fn", "Invalid etype fn def only")
        args = t.args or {}
        body = t.body
        ctx = self.ctx
        out = self.out
        ctx:pushScope("fn", t)
        out:append("function(" .. Utils.seqReduce(args, "", fn(init, i, v) {
            ctx:localInsert(v.value)
            return init .. (i > 1 and ", " or "") .. v.value
        }) .. ")")
        if #body > 0 {
            out:changeLine()
            out:incIndent()
            self:trStatement(body)
            if ctx:hasDefers() and body[#body].stype ~= "return" {
                out:append((#t > 0 and ", " or "") .. "__df_run__()")
            }
            out:decIndent()
        }
        out:append("end")
        if #body > 0 {
            out:changeLine()
        }
        ctx:popScope()
    }

    fn trEtRexp(t) {
        assert(t.etype == "rexp", "Invalid etype rexp")
        ctx = self.ctx
        out = self.out
        ctx:checkName(t[1])
        for i, e in ipairs(t) {
            if e.etype {
                self:trExpr(e)
            } elseif e.op {
                self:trOp(e)
            }
        }
    }

    fn trEtLexp(t) {
        assert(t.etype == "lexp", "Invalid etype lexp")
        ctx = self.ctx
        out = self.out
        ctx:checkName(t[1], (#t - 1) > 0)
        for i, e in ipairs(t) {
            if e.etype {
                self:trExpr(e)
            } elseif e.op {
                self:trOp(e)
            }
        }
    }

    -- MARK: Statement

    fn trStEqual(t) {
        assert(t.stype == "=", "Invalid stype equal")
        assert(#t == 2, "Invalid asign count")
        ctx = self.ctx
        out = self.out
        out:pushInline()
        for i, v in ipairs(t[1]) {
            if i == 1 {
                if not ctx:isVarDeclared(v, true) {
                    out:append("local ")
                }
            } else {
                out:append(", ")
            }
            self:trExpr(v)
        }
        out:append(" = ")
        for i, v in ipairs(t[2]) {
            if i > 1 {
                out:append(", ")
            }
            for _, n in ipairs(v) {
                self:trExpr(n)
            }
        }
        out:popInline()
        -- name
        for i, e in ipairs(t[1]) {
            if e.etype == "lexp" and #e == 1 {
                ctx:localInsert(e[1].value)
            }
        }
    }

    fn trStTwoEqual(t) {
        assert(t.stype:sub(2, 2) == "=", "Invalid stype two equal")
        ctx = self.ctx
        out = self.out
        assert(#t == 2, "Invalid asign count")
        out:pushInline()
        ctx:checkName(t[1], true)
        self:trExpr(t[1])
        out:append(" = ")
        self:trExpr(t[1])
        out:append(" " .. t.stype:sub(1, t.stype:len() - 1) .. " (")
        for _, v in ipairs(t[2]) {
            self:trExpr(v)
        }
        out:append(")")
        out:popInline()
    }

    fn trStComment(t) {
        assert(t.stype == "cm", "Invalid stype cm")
        self.out:append(t.value)
    }

    fn trStImport(t) {
        assert(t.stype == "import", "Invalid stype import")
        ctx = self.ctx
        out = self.out
        if #t <= 0 {
            out:append("require(" .. t.slib.value .. ")")
        } elseif t[2] == nil {
            lt = t[1][1]        
            if t.slib {
                out:append("local " .. lt.value .. " = require(" .. t.slib.value .. ")")
            } else {
                ctx:checkName(t.tlib, true)
                out:append("local " .. lt.value .. " = " .. t.tlib.value)
            }
            ctx:localInsert(lt.value)
        } else {
            lt = t[1]
            rt = t[2]
            if #rt <= 0 {
                rt = lt
            }
            out:append(Utils.seqReduce(lt, "local ", fn(init, i, v) {
                ctx:localInsert(v.value)
                return init .. (i > 1 and ", " or "") .. v.value
            }))
            out:append("do")
            out:incIndent()
            if t.slib {
                out:append("local __lib__ = require(" .. t.slib.value .. ")")
            } else {
                ctx:checkName(t.tlib, true)
                out:append("local __lib__ = " .. t.tlib.value)
            }
            out:append(Utils.seqReduce(lt, "", fn(init, i, v) {
                return init .. (i > 1 and ", " or "") .. v.value
            }))
            out:append(" = " .. Utils.seqReduce(rt, "", fn(init, i, v) {
                return init .. (i > 1 and ", __lib__." or "__lib__.") .. v.value
            }), true)
            out:decIndent()
            out:append("end")
        }
    }

    fn trStExport(t) {
        assert(t.stype == "ex", "Invalid stype export")
        ctx = self.ctx
        out = self.out
        out:pushInline()
        if t.attr == "local" {
            out:append("local ")
            for i, v in ipairs(t[1]) {
                if i > 1 {
                    out:append(", ")
                }
                self:trExpr(v)
                ctx:localInsert(v.value)
            }
            if t[2] {
                out:append(" = ")
                for i, e in ipairs(t[2]) {
                    if i > 1 {
                        out:append(", ")
                    }
                    for _, v in ipairs(e) {
                        self:trExpr(v)
                    }
                }
            }
        } elseif t.attr == "export" {
            for i, v in ipairs(t[1]) {
                ctx:globalInsert(v.value)
            }
            if t[2] {
                for i, v in ipairs(t[1]) {
                    if i > 1 {
                        out:append(",")
                    }
                    self:trExpr(v)
                }
                out:append(" = ")
                for i, e in ipairs(t[2]) {
                    if i > 1 {
                        out:append(", ")
                    }
                    for _, v in ipairs(e) {
                        self:trExpr(v)
                    }
                }
            }
        } else {
            ctx:errorPos("Invalid export attr near", (t.attr or "unknown"))
        }
        out:popInline()
    }

    fn trStFnDef(t) {
        assert(t.stype == "fn", "Invalid stype fn")
        attr = (t.attr == "export" and "" or "local ")
        name = t.name and t.name.value or ""
        args = t.args or {}
        body = t.body
        ctx = self.ctx
        out = self.out
        ctx:checkName(t.name, true, true)
        if t.attr == "export" {
            ctx:globalInsert(name)
        } else {
            ctx:localInsert(name)
        }
        ctx:pushScope("fn", t)
        out:append(attr .. "function " .. name .. "(" .. Utils.seqReduce(args, "", fn(init, i, v) {
            ctx:localInsert(v.value)
            return init .. (i > 1 and ", " or "") .. v.value
        }) .. ")")
        if #body > 0 {
            out:changeLine()
            out:incIndent()
            self:trStatement(body)
            if ctx:hasDefers() and body[#body].stype ~= "return" {
                out:append((#t > 0 and ", " or "") .. "__df_run__()")
            }
            out:decIndent()
        }
        out:append("end")
        ctx:popScope()
    }

    fn trStCall(t) {
        assert(t.stype == "(", "Invalid stype fn call")
        ctx = self.ctx
        out = self.out
        n = 0
        out:pushInline()        
        if t[1].etype == "lvar" {
            n = 1
            ctx:checkName(t[1], true)
            out:append(t[1].value, true)
        }
        for i, e in ipairs(t) {
            if i > n {
                if e.etype {
                    self:trExpr(e)
                } elseif e.op {
                    self:trOp(e)
                }
            }
        }
        out:popInline()
    }

    fn trStIfElse(t) {
        ctx = self.ctx
        out = self.out
        if t.stype == "if" or t.stype == "elseif" {
            out:append(t.stype .. " ")
            out:pushInline()
            for _, v in ipairs(t.cond) {
                self:trExpr(v)
            }
            out:popInline()
            out:append(" then", true)
            ctx:pushScope("if", t)
            out:changeLine()
            out:incIndent()
            self:trStatement(t.body)
            ctx:popScope()
            out:decIndent()
        } elseif t.stype == "else" {
            ctx:pushScope("if", t)
            out:append("else")        
            out:changeLine()
            out:incIndent()
            self:trStatement(t.body)
            out:decIndent()
            ctx:popScope()
        } elseif t.stype == "ifend" {
            out:append("end")
        } else {
            ctx:errorPos("Invalid stype near", (t.stype or "unknown"))
        }
    }

    fn trStSwitch(t) {
        assert(t.stype == "switch", "Invalid stype switch")
        ctx = self.ctx
        out = self.out
        out:append("do ", t)
        out:incIndent()
        out:append("local __sw__ = ")
        out:pushInline()
        for _, v in ipairs(t.cond) {
            self:trExpr(v)
        }
        out:popInline()
        out:changeLine()
        for i = 1, #t {
            c = t[i]
            out:pushInline()
            if c.stype == "case" {
                if i == 1 {
                    out:append("if ")
                } else {
                    out:append("elseif ")
                }
                out:append("__sw__ == (")
                for j, s in ipairs(c) {
                    if j > 1 {
                        out:append(") or __sw__ == (")
                    }
                    for _, e in ipairs(s) {
                        self:trExpr(e)
                    }
                }
                out:append(") then")
            } else {
                out:append("else")
            }
            out:changeLine()
            ctx:pushScope("if")
            out:popInline()
            out:incIndent()
            self:trStatement(c.body)
            out:decIndent()
            ctx:popScope()
        }
        out:append("end")
        out:changeLine()
        out:decIndent()
        out:append("end")
    }

    fn trStGuard(t) {
        assert(t.stype == "guard", "Invalid stype guard")
        ctx = self.ctx
        out = self.out
        body = t.body
        if #body <= 0 or body[#body].stype ~= "return" {
            ctx:errorPos("guard statement need return at last", "guard", t.pos - 1)
            return
        }
        out:append("if not (")
        out:pushInline()
        for _, v in ipairs(t.cond) {
            self:trExpr(v)
        }
        out:append(") then", true)
        out:popInline()
        out:changeLine()
        out:incIndent()
        ctx:pushScope("gu", t)
        self:trStatement(body)
        ctx:popScope()
        out:decIndent()
        out:append("end")
    }

    fn trStFor(t) {
        assert(t.stype == "for", "Invalid stype for")
        list = t.list
        staments = t.body
        ctx = self.ctx
        out = self.out    
        ctx:pushScope("lo", t)
        out:pushInline()
        out:append("for ")
        if list.sub == "=" {
            for i, e in ipairs(list) {
                if i == 1 {
                    self:trExpr(e)
                    out:append(" = ")
                    ctx:localInsert(e.value)
                } else {
                    if i > 2 {
                        out:append(", ")
                    }
                    for _, v in ipairs(e) {
                        self:trExpr(v)
                    }
                }
            }
        } elseif list.sub == "in" {
            for i, e in ipairs(list) {
                if i == #list {
                    out:append(" in ")
                } elseif i > 1 {
                    out:append(", ")
                }
                if i == #list {
                    for j, v in ipairs(e) {
                        if j > 1 {
                            out:append(", ")
                        }
                        for _, z in ipairs(v) {
                            self:trExpr(z)
                        }
                    }
                } else {
                    self:trExpr(e)
                }
                if i ~= #list {
                    ctx:localInsert(e.value)
                }
            }
        } else {
            ctx:errorPos("Invalid sub near", (list.sub or "unknown"))
            return
        }
        out:append(" do")
        out:popInline()
        out:changeLine()
        out:incIndent()
        self:trStatement(staments)
        out:decIndent()
        out:append("end")
        ctx:popScope()
    }

    fn trStWhile(t) {
        assert(t.stype == "while", "Invalid stype while")
        ctx = self.ctx
        out = self.out
        ctx:pushScope("lo", t)
        out:append("while ")    
        out:pushInline()
        for _, v in ipairs(t.cond) {
            self:trExpr(v)
        }
        out:append(" do")
        out:popInline()        
        out:changeLine()
        out:incIndent()
        self:trStatement(t.body)
        out:decIndent()
        out:append("end")
        ctx:popScope()
    }

    fn trStRepeat(t) {
        assert(t.stype == "repeat", "Invalid repeat op")
        ctx = self.ctx
        out = self.out
        ctx:pushScope("lo", t)
        out:append("repeat")
        out:changeLine()
        out:incIndent()
        self:trStatement(t.body)
        out:decIndent()
        out:append("until ")
        out:pushInline()
        for _, v in ipairs(t.cond) {
            self:trExpr(v)
        }
        out:popInline()
        ctx:popScope()
    }

    fn trStBreak(t) {
        assert(t.stype == "break", "Invalid stype break")
        ctx = self.ctx
        out = self.out
        if not ctx:isInLoop() {
            ctx:errorPos("not in loop", t.stype, t.pos - 1)
            return
        }
        out:append("break")
    }

    fn trStContinue(t) {
        assert(t.stype == "continue", "Invalid continue op")
        ctx = self.ctx
        out = self.out
        if not ctx:isInLoop() {
            ctx:errorPos("not in loop", t.stype, t.pos - 1)
            return
        }
        out:append("goto __continue__")
        if not out:isDryRun() {
            return
        }
        le = ctx:getScopeExpr("lo").body
        if #le == 0 or le[#le].stype ~= "raw" or le[#le].sub ~= "continue" {
            le[#le + 1] = { stype : "raw", sub : "continue", "::__continue__::"}
        }
    }

    fn trStGoto(t) {
        assert(t.stype == "goto" or t.stype == "::", "Invalid stype go")
        out = self.out
        if t.stype == "goto" {
            out:append("goto " .. t.name.value)
        } else {
            out:append("::" .. t.name.value .. "::")
        }
    }

    fn trStReturn(t) {
        assert(t.stype == "return", "Invalid stpye return")
        ctx = self.ctx
        out = self.out
        out:append("return ")
        out:pushInline()
        for i, e in ipairs(t) {
            if i > 1 {
                out:append(", ")
            }
            for _, v in ipairs(e) {
                self:trExpr(v)
            }
        }
        if ctx:hasDefers() {
            out:append((#t > 0 and ", " or "") .. "__df_run__()")
        }
        out:popInline()
    }

    fn trStDefer(t) {
        assert(t.stype == "defer", "Invalid stype defer")
        ctx = self.ctx
        out = self.out
        if not ctx:supportDefer() {
            ctx:errorPos("not in function", t.stype, t.pos)
            return
        }
        if out:isDryRun() {
            body = ctx:getScopeExpr("fn").body
            if #body == 0 or body[1].stype ~= "raw" or body[1].sub ~= "defer" {
                tbl = {
                    stype : "raw",
                    sub : "defer",
                    "local __df_fns__ = {}",
                    "local __df_run__ = function() local t=__df_fns__; for i=#t, 1, -1 do t[i]() end; end"
                }
                table.insert(body, 1, tbl)
            }
        } elseif not ctx.in_defer {
            ctx.in_defer = true
            out:append("__df_fns__[#__df_fns__ + 1] = function()")
            out:changeLine()
            out:incIndent()
            ctx:pushScope("df")
            self:trStatement(t.body)
            ctx:popScope()
            out:decIndent()
            out:append("end")
            ctx.in_defer = false
        }
    }

    fn trStDo(t) {
        assert(t.stype == "do", "Invalid stype do end")
        ctx = self.ctx
        out = self.out
        ctx:pushScope("do")
        out:append("do")
        out:changeLine()
        out:incIndent()
        self:trStatement(t.body)
        out:decIndent()
        out:append("end")
        ctx:popScope()
    }

    -- generated by compiler 1st pass
    fn trStRaw(t) {
        assert(t.stype == "raw", "Invalid stype raw")
        ctx = self.ctx
        if t.sub == "defer" {
            ctx:pushDefer()
        }
        out = self.out
        for _, v in ipairs(t) {
            out:append(v)
            out:changeLine()
        }
    }

    fn trStClass(t) {
        assert(t.stype == "class", "Invalid stype class")
        ctx = self.ctx
        out = self.out
        attr = (t.attr == "export") and "" or "local "
        clsname = t.name.value
        supertype = t.super and t.super.value
        if t.attr == "export" {
            ctx:globalInsert(clsname)
        } else {
            ctx:localInsert(clsname)
        }
        if supertype {
            ctx:checkName(t.super)
        }
        out:append(attr .. clsname .. " = {}")
        out:append("do")
        out:changeLine()
        out:incIndent()
        out:append("local __stype__ = " .. (supertype or "nil"))
        out:append('local __clsname__ = "' .. clsname .. '"')
        out:append("local __clstype__ = " .. clsname)
        if supertype {
            out:append('assert(type(__stype__) == "table" and type(__stype__.classtype) == "table")')
            out:append('for k, v in pairs(__stype__) do __clstype__[k] = v end')
        }
        out:append("__clstype__.classname = __clsname__")
        out:append("__clstype__.classtype = __clstype__")
        out:append("__clstype__.supertype = __stype__")
        if not supertype {
            out:append("__clstype__.isKindOf = function(cls, a) return a and ((cls.classtype == a) or (cls.supertype and cls.supertype:isKindOf(a))) or false end")
            out:append("__clstype__.isMemberOf = function(cls, a) return cls.classtype == a end")
            out:append("__clstype__.init = function() end")
        }
        --
        out:append("-- declare class var and methods")
        out:changeLine()
        fn_deinit = false
        cls_fns = {}
        ins_fns = {}
        for _, e in ipairs(t) {
            stype = e.stype
            if stype == "=" {
                ctx.in_clsvar = true         
                out:append("__clstype__.")
                out:pushInline()
                for i, v in ipairs(e) {
                    self:trExpr(v)
                    if i == 1 {
                        out:append(" = ")
                    }
                }
                out:popInline()
                out:changeLine()
                ctx.in_clsvar = false
            } elseif stype == "fn" {
                fn_name = e.name.value
                if fn_name == "deinit" {
                    fn_deinit = true
                }
                fn_ins = e.attr ~= "class"                
                if _cls_metafns[fn_name] {
                    if e.attr == "class" {
                        cls_fns[#cls_fns + 1] = e
                    } else {
                        ins_fns[#ins_fns + 1] = e
                    }
                } else {
                    out:append("function __clstype__" .. (fn_ins and ":" or ".") .. fn_name .. "(")
                    self:hlClsFnArgsBody(e, fn_ins, false)
                }
            } elseif stype == "cm" {
                self:trStComment(e)
            }
        }
        out:append("-- declare end")
        --
        out:append("local __ins_mt = {")
        out:incIndent()
        out:append('__tostring = function() return "instance of " .. __clsname__ end,')
        out:append("__index = function(t, k) return rawget(t, k) or __clstype__[k] end,")
        if fn_deinit {
            out:append("__gc = function(t) t:deinit() end,")
        }
        for _, e in ipairs(ins_fns) {
            out:append(e.name.value .. " = function(")
            self:hlClsFnArgsBody(e, false, true)
        }
        out:decIndent()
        out:append("}")
        --
        out:append("setmetatable(__clstype__, {")
        out:incIndent()
        out:append('__tostring = function() return "class " .. __clsname__ end,')
        out:append('__index = function(_, k) return rawget(__clstype__, k) or (__stype__ and __stype__[k]) end,')
        out:append('__newindex = function() end,')
        out:append("__call = function(_, ...)")
        out:incIndent()
        out:append("local ins = setmetatable({}, __ins_mt)")
        if fn_deinit {
            out:append('if _VERSION == "Lua 5.1" then')
            out:incIndent()
            out:append("ins.__gc_proxy = newproxy(true)")
            out:append("getmetatable(ins.__gc_proxy).__gc = function() ins:deinit() end")
            out:decIndent()
            out:append("end")
        }
        out:append("ins:init(...)")
        out:append("return ins")
        out:decIndent()
        out:append("end,")
        for _, e in ipairs(cls_fns) {
            out:append(e.name.value .. " = function(")
            self:hlClsFnArgsBody(e, false, true)
        }
        out:decIndent()
        out:append("})")
        --
        out:decIndent()
        out:append("end")
    }

    fn hlClsFnArgsBody(e, fn_ins, comma_end) {
        ctx = self.ctx
        out = self.out
        out:pushInline()
        ctx:pushScope("fn", e)
        if e.args {
            for i, v in ipairs(e.args) {
                if i > 1 {
                    out:append(", ")
                }
                self:trExpr(v)
                ctx:localInsert(v.value)
            }
        }
        if fn_ins {
            ctx:localInsert("self")
        }
        out:append(")")
        out:changeLine()
        out:popInline()
        out:incIndent()
        self:trStatement(e.body)
        out:decIndent()
        out:append("end" .. (comma_end and "," or ""))
        out:changeLine()
        ctx:popScope()
    }
}

--[[
    config as { fname : "filename", shebang : false }    
    data as { content : CONTENT, ast : AST_TREE }
]]
fn compile(config, data) {
    assert(type(data) == "table", "Invalid data")
    assert(type(data.ast) == "table", "Invalid AST")
    assert(type(data.content) == "string", "Invalid content")

    ctx = Ctx(config, data.ast, data.content)
    out = Out()

    comp = M(ctx, out)
    out:reset(true)
    comp:trStatement(ctx.ast)

    if ctx:hasError() {
        return false, ctx.error
    }

    ctx:reset()
    out:reset()
    comp:trStatement(ctx.ast)

    return true, table.concat(out._output, "\n")
}

return { :compile }
